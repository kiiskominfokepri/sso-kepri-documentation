{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#selamat-datang-di-sso-kepri","title":"Selamat Datang di SSO-KEPRI","text":"<p>SSO-KEPRI merupakan server autentikasi dan otorisasi yang kami bangun untuk mengintegrasikan aplikasi di lingkungan Pemerintahan Provinsi Kepulauan Riau.</p>"},{"location":"about/","title":"About","text":""},{"location":"client-registration/","title":"Client Registration","text":"<p>Pendaftaran aplikasi klien akan dilakukan oleh <code>Pengelola Utama</code> dari portal SSO-KEPRI. Anda akan mendapatkan beberapa informasi, seperti:</p> <ol> <li><code>Client identifier</code> atau <code>client-id</code>, adalah id yang dibutuhkan untuk menyatakan identitas klien.</li> <li><code>Client secret</code>, adalah string rahasia yang dibutuhkan untuk memverifikasi validitas dari request klien. *Informasi ini harus dijaga agar tidak dapat diakses oleh pengguna tak berizin.</li> </ol> <p>Untuk mendapatkan akses ke OAuth milik SSO-KEPRI, Anda harus menyiapkan beberapa informasi berikut ini:</p> <ol> <li><code>Redirect URI</code>, kami membutuhkan daftar <code>URI</code> yang Anda siapkan sebagai <code>handler callback</code> dari kami. Kami akan meneruskan hasil dari autentikasi ke <code>URI</code> yang telah Anda daftarkan.</li> <li><code>Resource permission</code>, kami harus mengetahui resource yang akan Anda akses melalui OAuth. Kami akan membatasi apa yang <code>boleh</code> dan apa yang <code>tidak boleh</code> Anda akses dari portal SSO-KEPRI.</li> </ol>"},{"location":"endpoints/","title":"Endpoints","text":""},{"location":"endpoints/#well-known-discovery-url","title":"Well-known discovery URL","text":"<p>You can find a link to the well-known discovery URL by going to the root of Goiabada (\"/\"). </p> <p><code>https://sso.kepriprov.go.id/.well-known/openid-configuration</code></p> <p>This endpoint will show the capabilities that are supported by Goiabada.</p>"},{"location":"endpoints/#authauthorize-get","title":"/auth/authorize (GET)","text":"<p>The authorize endpoint is used to request authorization codes via the browser. This process normally involves authentication of the end-user and giving consent, when required.</p> <p>Parameters (* are mandatory):</p> Parameter Description client_id The client identifier. redirect_uri The redirect URI is the callback entry point of the app. In other words, it's the location where the authorization server sends the user once the <code>/auth/authorize</code> process completes. This must exactly match one of the allowed redirect URIs for the client. response_type <code>code</code> is the only value supported - for the authorization code flow with PKCE. code_challenge_method <code>S256</code> is the only value supported - for a SHA256 hash of the code verifier. code_challenge A random string between 43 and 128 characters long. response_mode Supported values: <code>query</code>, <code>fragment</code> or <code>form_post</code>. With <code>query</code> the authorization response parameters are encoded in the query string of the <code>redirect_uri</code>. With <code>fragment</code> they are encoded in the fragment (#). And <code>form_post</code> will make the parameters be encoded as HTML form values that are auto-submitted in the browser, via HTTP POST. max_age If the user's authentication timestamp exceeds the max age (in seconds), they will have to re-authenticate acr_values Supported values are: <code>urn:goiabada:pwd</code>, <code>urn:goiabada:pwd:otp_ifpossible</code> or <code>urn:goiabada:pwd:otp_mandatory</code>. This will override the default ACR level configured in the client for this authorization request. See Default ACR level. state Any string. Goiabada will echo back the state value on the token response, for CSRF/replay protection. nonce Any string. Goiabada will echo back the nonce value in the identity token, as a claim, for replay protection. scope One or more registered scopes, separated by a space character. A registered scope can be either a <code>resource:permission</code> or an OIDC scope. See Scope and OpenID Connect scopes."},{"location":"endpoints/#authtoken-post","title":"/auth/token (POST)","text":"<p>The token endpoint serves the purpose of requesting tokens. This can happen either through the authorization code flow, involving the exchange of an authorization code for tokens, or through the client credentials flow, where a client directly requests tokens.</p> <p>Parameters:</p> Parameter Description grant_type Supported grant types are <code>authorization_code</code> (to exchange an authorization code for tokens), <code>client_credentials</code> (for the client credentials flow) or <code>refresh_token</code> (to use a refresh token). client_id The client identifier. client_secret The client secret, if it's a confidential client. redirect_uri Required for the <code>authorization_code</code> grant type. code The authorization code. Required for the <code>authorization_code</code> grant type. code_verifier This is the code verifier associated with the PKCE request, initially generated by the app before the authorization request. It represents the original string from which the <code>code_challenge</code> was derived. scope This parameter is used in the <code>client_credentials</code> and <code>refresh_token</code> grant types. In <code>client_credentials</code> grant type, it's a mandatory parameter, and it should encompass one or more registered scopes, separated by a space character. These scopes represent the requested permissions in the format of <code>resource:permission</code>. For the <code>refresh_token</code> grant type, the scope parameter is optional and serves to restrict the original scope to a more specific and narrower subset. refresh_token The refresh token, required for the <code>refresh_token</code> grant type."},{"location":"endpoints/#authlogout-get-or-post","title":"/auth/logout (GET or POST)","text":"<p>This endpoint enables the client application to initiate a logout. The client application calls this logout endpoint on the auth server. Upon successful logout from the auth server, the user agent is then redirected to a logout link within the client application. This implementation aligns with the OpenID Connect RP-Initiated Logout 1.0 protocol.</p> <p>If the <code>/auth/logout</code> endpoint is invoked without parameters, it will display a logout consent screen, prompting the user to confirm their intention to log out. Moreover, there will be no redirection to the client application in this scenario.</p> <p>The recommended way of calling <code>/auth/logout</code> involves including additional parameters:</p> Parameter Description id_token_hint The previously issued id token. post_logout_redirect_uri A post-logout URI, which must be pre-registered with the client as a redirect URI. Once the logout is finalized on the authentication server, the user agent will be redirected to this post-logout URI. This allows for the termination of the session on the client application as well. client_id The client identifier. Mandatory if the <code>id_token_hint</code> parameter is encrypted with the client secret. state Any arbitraty string that will be echoed back in the <code>post_logout_redirect_uri</code>. <p>The two possible routes are:</p> <ol> <li><code>id_token_hint</code> (unencrypted) + <code>post_logout_redirect_uri</code> + <code>state</code> (optional).  </li> <li><code>id_token_hint</code> (encrypted with AES GCM) + <code>post_logout_redirect_uri</code> + <code>client_id</code> + <code>state</code> (optional).  </li> </ol> <p>Encrypting the <code>id_token_hint</code> (option 2) enhances security by preventing the exposure of the ID token on the client side. Without encryption, calling this endpoint with an unencrypted <code>id_token_hint</code> could potentially expose personally identifiable information (PII) and other claims that are inside of the id token, such as the client identifier. You must URL-encode the resulting base64 string, when sending it as querystring parameter to <code>/auth/logout</code>.</p>"},{"location":"endpoints/#userinfo-get-or-post","title":"/userinfo (GET or POST)","text":"<p>The UserInfo endpoint, a component of OpenID Connect, serves the purpose of retrieving identity information about a user.</p> <p>The caller needs to send a valid access token to be able to access this endpoint. This is done by adding the <code>Authorization: Bearer token-value</code> header to the HTTP request.</p> <p>The endpoint validates the presence of the <code>authserver:userinfo</code> scope within the access token. If this scope is present, the endpoint responds by providing claims about the user. </p> <p>Please note that you don't need to manually request the <code>authserver:userinfo</code> scope in the authorization request. Instead, it will be automatically included in the access token whenever any OpenID Connect scope is included in the request.</p> <p>The specific claims returned by the UserInfo endpoint depend on the OpenID Connect scopes included in the access token. For instance, if the <code>openid</code> and <code>email</code> scopes are present, the endpoint will return the <code>sub</code> (subject) claim from the <code>openid</code> scope, as well as the <code>email</code> and <code>email_verified</code> claims from the email scope.</p>"},{"location":"license/","title":"License","text":""},{"location":"mobile-and-native-apps/","title":"Mobile &amp; Native Apps","text":""},{"location":"scopes/","title":"OpenID Connect scopes","text":"<p>Selain cakupan otorisasi normal yang dijelaskan sebelumnya, SSO-KEPRI mendukung <code>scopes</code> OpenID Connect yang umum, diantaranya:</p> OIDC scope Deskripsi openid Akan menyertakan <code>id_token</code> dalam respon token, dengan pengidentifikasi subjek (<code>sub</code> claim) profile Akses ke data: <code>name</code>, <code>family_name</code>, <code>given_name</code>, <code>middle_name</code>, <code>nickname</code>, <code>preferred_username</code>, <code>profile</code>, <code>website</code>, <code>gender</code>, <code>birthdate</code>, <code>zoneinfo</code>, <code>locale</code>, dan <code>updated_at</code> email Akses ke data: <code>email</code>, <code>email_verified</code> address Akses ke data <code>address</code> phone Akses ke data: <code>phone_number</code> dan <code>phone_number_verified</code> groups Akses ke daftar grup tempat pengguna berada attributes Akses ke atribut yang diberikan kepada pengguna oleh admin, disimpan sebagai pasangan nilai-kunci (key-value pairs) offline_access Akses ke token penyegaran jenis <code>Offline</code>, memungkinkan klien mendapatkan token akses baru tanpa memerlukan interaksi langsung"},{"location":"server-side-apps/","title":"Server-Side Apps","text":""},{"location":"server-side-apps/#php-based-apps","title":"PHP-Based Apps","text":""},{"location":"server-side-apps/#laravel-7x","title":"Laravel 7.x+","text":"<p>Laravel menyediakan cara sederhana dan nyaman untuk mengautentikasi dengan penyedia OAuth menggunakan Laravel Socialite. Socialite saat ini mendukung otentikasi melalui Facebook, Twitter, LinkedIn, Google, GitHub, GitLab, Bitbucket, dan Slack. Kita dapat membuat <code>CustomProvider</code> untuk menggunakan SSO-KEPRI sebagai salah satu penyedia yang didukung oleh Socialite.</p> <p>Untuk memulai Socialite, gunakan manajer paket Composer untuk menambahkan paket ke dependensi proyek Anda:</p> <pre><code>composer require laravel/socialite\n</code></pre> <p>Sebelum menggunakan Socialite, Anda perlu menambahkan kredensial untuk penyedia OAuth yang digunakan aplikasi Anda. Dalam hal ini, kredensial didapat dari hasil pendaftaran <code>aplikasi klien</code> pada portal SSO-KEPRI.</p> <p>Kredensial ini harus ditempatkan di file konfigurasi <code>config/services.php</code> aplikasi Anda, dengan konten di bawah:</p> <pre><code>&lt;?php\n\nreturn [\n    // ... isi file config/services.php saat ini\n\n    'sso-kepri' =&gt; [\n        'base_uri' =&gt; 'https://sso.kepriprov.go.id',\n        'client_id' =&gt; '&lt;your-sso-client-id&gt;',\n        'client_secret' =&gt; '&lt;your-sso-client-secret&gt;',\n        'redirect' =&gt; '&lt;your-client-url-callback&gt;',\n    ],\n\n    // ... isi file config/services.php saat ini\n];\n</code></pre> <p>Sekarang, Anda harus membuat kelas <code>SocialiteSsoProvider</code> yang diturunkan dari <code>\\Socialite\\Two\\AbstractProvider</code>. Anda perlu menerapkan metode dibawah ini agar driver berfungsi seperti yang diharapkan:</p> <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Laravel\\Socialite\\Two\\AbstractProvider;\nuse Laravel\\Socialite\\Two\\ProviderInterface;\n\nclass SocialiteSsoProvider extends AbstractProvider implements ProviderInterface\n{\n    /**\n     * The scopes being requested.\n     *\n     * @var string[]\n     */\n    protected $scopes = [\"openid\", \"profile\", \"email\"];\n\n    /**\n     * @var string\n     */\n    protected $scopeSeparator = ' ';\n\n    /**\n     * Indicates if PKCE should be used.\n     *\n     * @var bool\n     */\n    protected $usesPKCE = true;\n\n    /**\n     * @return string\n     */\n    public function getSsoUrl()\n    {\n        return config('services.sso-kepri.base_uri');\n    }\n\n    /**\n     * @param string $state\n     *\n     * @return string\n     */\n    protected function getAuthUrl($state)\n    {\n        return $this-&gt;buildAuthUrlFromBase($this-&gt;getSsoUrl() . '/auth/authorize', $state);\n    }\n\n    /**\n     * @return string\n     */\n    protected function getTokenUrl()\n    {\n        return $this-&gt;getSsoUrl() . '/auth/token';\n    }\n\n    /**\n     * @param string $token\n     *\n     * @throws GuzzleException\n     *\n     * @return array|mixed\n     */\n    protected function getUserByToken($token)\n    {\n        $response = $this-&gt;getHttpClient()-&gt;get($this-&gt;getSsoUrl() . '/userinfo', [\n            'headers' =&gt; [\n                'cache-control' =&gt; 'no-cache',\n                'Authorization' =&gt; 'Bearer ' . $token,\n                'Content-Type' =&gt; 'application/x-www-form-urlencoded',\n            ],\n        ]);\n\n        return json_decode($response-&gt;getBody()-&gt;getContents(), true);\n    }\n\n    /**\n     * @return \\Laravel\\Socialite\\Two\\User\n     */\n    protected function mapUserToObject(array $user)\n    {\n        return (new \\Laravel\\Socialite\\Two\\User())-&gt;setRaw($user)-&gt;map([\n            'id' =&gt; $user['sub'],\n            'email' =&gt; $user['email'],\n            'username' =&gt; $user['email'],\n            'email_verified' =&gt; $user['email_verified'],\n            'name' =&gt; $user['name'],\n        ]);\n    }\n\n}\n</code></pre> <p>Untuk membuat <code>CustomProvider</code> yang telah dibuat dapat dikenali oleh Socialite, Anda perlu menambahkan beberapa kode di file <code>app/Providers/AppServiceProvider.php</code>:</p> <pre><code>&lt;?php\n\nnamespace App\\Providers;\n\nuse Laravel\\Socialite\\Contracts\\Factory;\n// ... isi file app/Providers/AppServiceProvider.php saat ini\n\nclass AppServiceProvider extends ServiceProvider\n{\n\n    // ... isi class AppServiceProvider saat ini\n\n    public function boot(): void\n    {\n        // .. isi method boot() saat ini\n\n        $socialite = $this-&gt;app-&gt;make(Factory::class);\n        $socialite-&gt;extend('sso-kepri', function () use ($socialite) {\n            $config = config('services.sso-kepri');\n            return $socialite-&gt;buildProvider(SocialiteSsoProvider::class, $config);\n        });\n\n        // .. isi method boot() saat ini\n    }\n\n    // ... isi class AppServiceProvider saat ini\n}\n</code></pre> <p>Sekarang Anda harus membuat dua route di dalam file <code>routes/web.php</code>. Kedua route tersebut adalah: 1. <code>/auth/redirect</code> [GET], untuk meneruskan ke halaman autentikasi SSO-KEPRI. 2. <code>/auth/callback</code> [GET], untuk menghandle <code>callback</code> dari SSO-KEPRI. Dapat diolah sesuai kebutuhan, misal: (mencari data pengguna aplikasi yang terkait dengan email SSO, melakukan otomasi login berdasarkan akun SSO yang didapat dari callback, dll).  </p> <pre><code>// ... isi file routes/web.php saat ini\n\nRoute::get('/auth/redirect', function () {\n    // redirect ke halaman autentikasi SSO-KEPRI\n    return Socialite::driver('sso-kepri')-&gt;redirect();\n})-&gt;name('sso.auth');\n\nRoute::get('/auth/callback', function () {\n    try {\n        if (\\Illuminate\\Support\\Facades\\Auth::check()) {\n            // redirect ke halaman dashboard/home dari aplikasi jika terdapat sesi aktif\n            return redirect(route('dashboard')); \n        }\n\n        /** [Bagian Penting!!!]. Mengambil data user yang didapat dari callback SSO-KEPRI **/\n        $ssoUser = Socialite::driver('sso-kepri')-&gt;user();\n\n        // mencari data user di database local, berdasarkan email akun SSO-KEPRI\n        $user = User::query()-&gt;whereEmail($ssoUser-&gt;email)-&gt;first();\n        if (!$user) {\n            // redirect ke halaman login jika akun SSO-KEPRI tidak terdaftar sebagai pengguna aplikasi\n            return redirect('login')-&gt;with('error', 'Pengguna tidak memiliki akses pada aplikasi ini.');\n        }\n\n        /** \n         * Eksekusi auto-login berdasarkan data user \n         * Tergantung pada metode login masing-masing aplikasi (menggunakan Sanctum, Passport, Auth, dll) \n        **/\n        \\Illuminate\\Support\\Facades\\Auth::guard('web')-&gt;login($user);\n        return redirect(route('dashboard'))-&gt;with('success', 'Selamat datang, '.$user-&gt;name);\n    } catch (\\Exception $exception) {\n        // redirect ke halaman login jika terjadi kesalahan saat mencoba mendapatkan akun SSO-KEPRI\n        return redirect('login')-&gt;with('error', 'Kredensial yang diberikan tidak valid.');\n    }\n})-&gt;name('sso.callback');\n\n// ... isi file routes/web.php saat ini\n</code></pre> <p>Handler dari kedua route ini dapat langsung ditulis pada file <code>routes/web.php</code>, atau dapat dibuat <code>Controller</code> tambahan untuk menghandle route (seperti route handler pada umumnya).</p>"},{"location":"server-side-apps/#codeigniter-3","title":"CodeIgniter 3","text":"<p>On-progress</p>"}]}